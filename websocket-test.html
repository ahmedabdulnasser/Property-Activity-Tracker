<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebSocket Test Client</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      .container {
        max-width: 800px;
        margin: 0 auto;
      }
      .section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      .logs {
        background: #f5f5f5;
        padding: 10px;
        height: 200px;
        overflow-y: scroll;
        font-family: monospace;
        font-size: 12px;
      }
      button {
        margin: 5px;
        padding: 8px 16px;
      }
      input,
      select {
        margin: 5px;
        padding: 5px;
      }
      .success {
        color: green;
      }
      .error {
        color: red;
      }
      .info {
        color: blue;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Property Activity Tracker - WebSocket Test</h1>

      <div class="section">
        <h3>Authentication</h3>
        <input
          type="email"
          id="email"
          placeholder="Email"
          value="admin@example.com"
        />
        <input
          type="password"
          id="password"
          placeholder="Password"
          value="admin123"
        />
        <button onclick="login()">Login</button>
        <span id="loginStatus">Not logged in</span>
      </div>

      <div class="section">
        <h3>Connection Status</h3>
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()">Disconnect</button>
        <span id="status">Disconnected</span>
      </div>

      <div class="section">
        <h3>User Actions</h3>
        <input type="number" id="userId" placeholder="User ID" value="1" />
        <button onclick="joinUser()">Join as User</button>
        <button onclick="getRecentActivities()">Get Recent Activities</button>
      </div>

      <div class="section">
        <h3>Test Activities</h3>
        <select id="activityType">
          <option value="visit">Visit (10 points)</option>
          <option value="call">Call (8 points)</option>
          <option value="inspection">Inspection (6 points)</option>
          <option value="follow-up">Follow-up (4 points)</option>
          <option value="note">Note (2 points)</option>
        </select>
        <input
          type="number"
          id="propertyId"
          placeholder="Property ID"
          value="1"
        />
        <input type="text" id="note" placeholder="Note (optional)" />
        <button onclick="createActivity()">Create Activity</button>
      </div>

      <div class="section">
        <h3>Replay & Missing Activities</h3>
        <input type="datetime-local" id="replayFrom" placeholder="From" />
        <input type="datetime-local" id="replayTo" placeholder="To" />
        <input
          type="number"
          id="replaySpeed"
          placeholder="Speed (ms)"
          value="1000"
        />
        <button onclick="replayActivities()">Replay Activities</button>
        <br /><br />
        <input
          type="datetime-local"
          id="missedSince"
          placeholder="Missed Since"
        />
        <button onclick="getMissedActivities()">Get Missed Activities</button>
        <button onclick="getMissedSinceDisconnect()">
          Get Missed Since Last Disconnect
        </button>
      </div>

      <div class="section">
        <h3>Test Scenarios</h3>
        <button onclick="testHighScoreNotification()">
          üèÜ Test High Score (100+ points)
        </button>
        <button onclick="testOpportunityNotification()">
          üíº Test Opportunity Notification
        </button>
        <button onclick="testReplayScenario()">üìº Test Replay Scenario</button>
        <button onclick="testLiveUpdates()">üî¥ Test Live Updates</button>
      </div>

      <div class="section">
        <h3>WebSocket Logs</h3>
        <div id="logs" class="logs"></div>
        <button onclick="clearLogs()">Clear Logs</button>
      </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
      let socket = null;
      let userId = 1;
      let authToken = null;
      let lastConnectedTime = null;

      function log(message, type = "info") {
        const logs = document.getElementById("logs");
        const timestamp = new Date().toLocaleTimeString();
        const className =
          type === "error" ? "error" : type === "success" ? "success" : "info";
        logs.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
        logs.scrollTop = logs.scrollHeight;
      }

      function updateStatus(status) {
        document.getElementById("status").textContent = status;
      }

      function updateLoginStatus(status) {
        document.getElementById("loginStatus").textContent = status;
      }

      async function login() {
        const email = document.getElementById("email").value;
        const password = document.getElementById("password").value;

        try {
          const response = await fetch("http://localhost:3000/auth/login", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ email, password }),
          });

          if (response.ok) {
            const data = await response.json();
            authToken = data.access_token;
            userId = data.user.id;
            document.getElementById("userId").value = userId;
            log(`Login successful! User ID: ${userId}`, "success");
            updateLoginStatus("Logged in");
          } else {
            const errorData = await response.json();
            log(`Login failed: ${errorData.message}`, "error");
            updateLoginStatus("Login failed");
          }
        } catch (error) {
          log(`Login error: ${error.message}`, "error");
          updateLoginStatus("Login error");
        }
      }

      function connect() {
        if (socket) {
          log("Already connected", "error");
          return;
        }

        if (!authToken) {
          log("Please login first to get authentication token", "error");
          return;
        }

        // Connect with JWT authentication
        socket = io("http://localhost:3000", {
          auth: {
            token: authToken,
          },
        });

        socket.on("connect", () => {
          log("‚úÖ Connected to WebSocket server", "success");
          updateStatus("Connected");
          lastConnectedTime = new Date().toISOString();
        });

        socket.on("disconnect", () => {
          log("‚ùå Disconnected from WebSocket server", "error");
          updateStatus("Disconnected");
          socket = null;
        });

        socket.on("connected", (data) => {
          log(
            `‚úÖ Server says: ${data.message} (User ID: ${data.userId})`,
            "success"
          );
          if (data.userId) {
            userId = data.userId;
            document.getElementById("userId").value = userId;
          }
        });

        socket.on("user-joined", (data) => {
          log(`üë§ User joined: ${JSON.stringify(data)}`, "success");
        });

        socket.on("recent-activities", (activities) => {
          log(
            `Recent activities received: ${activities.length} activities`,
            "success"
          );
          activities.forEach((activity) => {
            log(
              `  - ${activity.activityType?.name || "Unknown"} by ${
                activity.salesRep?.user?.name || "Unknown"
              } at ${activity.timestamp}`
            );
          });
        });

        socket.on("new-activity", (activity) => {
          log(
            `üî¥ LIVE: New activity - ${
              activity.activityType?.name || "Unknown"
            } by ${activity.salesRep?.user?.name || "Unknown"}`,
            "success"
          );
        });

        socket.on("user-activity", (activity) => {
          log(
            `üë§ User activity: ${activity.activityType?.name || "Unknown"}`,
            "info"
          );
        });

        socket.on("leaderboard-update", (leaderboard) => {
          log(`üìä Leaderboard update: ${leaderboard.length} users`, "success");
          leaderboard.slice(0, 3).forEach((user, index) => {
            log(
              `  ${index + 1}. ${user.user?.name || "Unknown"}: ${
                user.score
              } points`
            );
          });
        });

        socket.on("notification", (notification) => {
          log(
            `üîî NOTIFICATION [${notification.type}]: ${notification.message}`,
            "success"
          );

          // Show notification prominently
          if (notification.type === "high_score") {
            log(`üèÜ HIGH SCORE ACHIEVEMENT! üèÜ`, "success");
          } else if (notification.type === "opportunity") {
            log(`üíº BUSINESS OPPORTUNITY! üíº`, "success");
          }
        });

        // Replay and Missing Activities Event Listeners
        socket.on("missed-activities", (activities) => {
          log(
            `üì• Missed activities received: ${activities.length} activities`,
            "success"
          );
          activities.forEach((activity, index) => {
            log(
              `  ${index + 1}. ${activity.activityType?.name || "Unknown"} by ${
                activity.salesRep?.user?.name || "Unknown"
              } at ${activity.timestamp}`
            );
          });
        });

        socket.on("missed-activities-since-disconnect", (data) => {
          log(
            `üì• Fast-forward replay: ${data.count} missed activities since ${data.since}`,
            "success"
          );
          if (data.activities.length === 0) {
            log("No missed activities during offline period.", "info");
            return;
          }

          // Automatically start fast-forwarded replay visual
          let replayIndex = 0;
          function replayNext() {
            if (replayIndex < data.activities.length) {
              const activity = data.activities[replayIndex];
              log(
                `üé¨ REPLAY [${replayIndex + 1}/${data.activities.length}]: ${
                  activity.activityType?.name || "Unknown"
                } by ${activity.salesRep?.user?.name || "Unknown"} at ${
                  activity.timestamp
                } <span style='color: orange;'>[REPLAY]</span>`,
                "info"
              );
              // Optionally, trigger any map or UI visual here
              replayIndex++;
              setTimeout(replayNext, 200); // 200ms between each for fast-forward effect
            } else {
              log("‚è© Fast-forward replay finished!", "success");
            }
          }
          replayNext();
        });

        socket.on("replay-started", (data) => {
          log(
            `‚ñ∂Ô∏è REPLAY STARTED: ${data.totalActivities} activities to replay`,
            "success"
          );
        });

        socket.on("replay-activity", (data) => {
          log(
            `üé¨ REPLAY [${data.index}/${data.total}]: ${
              data.activity.activityType?.name || "Unknown"
            } by ${data.activity.salesRep?.user?.name || "Unknown"}`,
            "info"
          );
        });

        socket.on("replay-finished", (data) => {
          log(
            `‚èπÔ∏è REPLAY FINISHED: ${data.totalActivities} activities replayed`,
            "success"
          );
        });

        socket.on("error", (error) => {
          log(`Error: ${error.message}`, "error");
        });

        socket.on("connect_error", (error) => {
          log(`‚ùå Connection error: ${error.message}`, "error");
          if (
            error.message.includes("Authentication") ||
            error.message.includes("Unauthorized")
          ) {
            log(
              "üí° Hint: Make sure you're logged in with valid credentials",
              "info"
            );
            updateLoginStatus("Authentication failed");
          }
          updateStatus("Connection Error");
        });
      }

      function disconnect() {
        if (socket) {
          socket.disconnect();
          socket = null;
          updateStatus("Disconnected");
          log("Disconnected", "info");
        }
      }

      function joinUser() {
        if (!socket) {
          log("Not connected to WebSocket", "error");
          return;
        }
        userId = parseInt(document.getElementById("userId").value);
        socket.emit("join-user", { userId });
        log(`Joining as user ${userId}...`, "info");
      }

      function getRecentActivities() {
        if (!socket) {
          log("Not connected to WebSocket", "error");
          return;
        }
        socket.emit("get-recent-activities", { minutes: 60 });
        log("Requesting recent activities...", "info");
      }

      async function createActivity() {
        const activityType = document.getElementById("activityType").value;
        const propertyId = parseInt(
          document.getElementById("propertyId").value
        );
        const note = document.getElementById("note").value;

        const activityData = {
          activityTypeId: getActivityTypeId(activityType),
          propertyId: propertyId,
          salesRepId: userId,
          note: note || null,
        };

        try {
          log(`Creating ${activityType} activity...`, "info");

          if (!authToken) {
            log("‚ùå No authentication token available", "error");
            return;
          }

          const response = await fetch("http://localhost:3000/activities", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify(activityData),
          });

          if (response.ok) {
            const activity = await response.json();
            log(`‚úÖ Activity created: ${activity.id}`, "success");
          } else {
            const error = await response.text();
            log(`‚ùå Failed to create activity: ${error}`, "error");
          }
        } catch (error) {
          log(`‚ùå Error creating activity: ${error.message}`, "error");
        }
      }

      function getActivityTypeId(activityType) {
        const mapping = {
          visit: 1,
          call: 2,
          inspection: 3,
          "follow-up": 4,
          note: 5,
        };
        return mapping[activityType] || 1;
      }

      async function testHighScoreNotification() {
        log("üß™ Testing high score notification...", "info");
        log(
          "üí° Creating 10 visit activities (10 points each = 100 points total)",
          "info"
        );

        // Create 10 visit activities to reach 100 points
        for (let i = 0; i < 10; i++) {
          try {
            // Set activity type to visit (should be ID 1 based on typical seed data)
            const activityData = {
              activityTypeId: 1, // visit
              propertyId: (i % 5) + 1, // Cycle through properties 1-5
              salesRepId: userId,
              note: `High score test activity ${i + 1}/10`,
            };

            const response = await fetch("http://localhost:3000/activities", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${authToken}`,
              },
              body: JSON.stringify(activityData),
            });

            if (response.ok) {
              const activity = await response.json();
              log(`‚úÖ Activity ${i + 1}/10 created: ${activity.id}`, "success");
            } else {
              const error = await response.text();
              log(`‚ùå Failed to create activity ${i + 1}: ${error}`, "error");
            }

            // Wait 500ms between activities to see progression
            await new Promise((resolve) => setTimeout(resolve, 500));
          } catch (error) {
            log(
              `‚ùå Error creating activity ${i + 1}: ${error.message}`,
              "error"
            );
          }
        }

        log(
          "üéØ Should have triggered high score notification at 100 points!",
          "info"
        );
      }

      async function testOpportunityNotification() {
        log("üß™ Testing opportunity notifications...", "info");
        log(
          "üí° Creating visit and inspection activities (both trigger opportunities)",
          "info"
        );

        try {
          // Create a visit activity (triggers opportunity notification)
          const visitActivity = {
            activityTypeId: 1, // visit
            propertyId: 1,
            salesRepId: userId,
            note: "High-impact visit activity test",
          };

          let response = await fetch("http://localhost:3000/activities", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify(visitActivity),
          });

          if (response.ok) {
            log(
              `‚úÖ Visit activity created - should trigger opportunity notification`,
              "success"
            );
          }

          await new Promise((resolve) => setTimeout(resolve, 1000));

          // Create an inspection activity (also triggers opportunity notification)
          const inspectionActivity = {
            activityTypeId: 3, // inspection (assuming ID 3 based on typical seed)
            propertyId: 2,
            salesRepId: userId,
            note: "High-impact inspection activity test",
          };

          response = await fetch("http://localhost:3000/activities", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify(inspectionActivity),
          });

          if (response.ok) {
            log(
              `‚úÖ Inspection activity created - should trigger opportunity notification`,
              "success"
            );
          }
        } catch (error) {
          log(
            `‚ùå Error testing opportunity notifications: ${error.message}`,
            "error"
          );
        }

        log("üéØ Should have triggered 2 opportunity notifications!", "info");
      }

      async function testReplayScenario() {
        log("üß™ Testing replay scenario...", "info");
        log("1. Disconnect to simulate going offline...", "info");
        disconnect();

        await new Promise((resolve) => setTimeout(resolve, 2000));

        log('2. Create activities while "offline" (using REST API)...', "info");
        for (let i = 0; i < 3; i++) {
          await createActivity();
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        await new Promise((resolve) => setTimeout(resolve, 2000));

        log("3. Reconnect to see missed activities...", "info");
        connect();

        setTimeout(() => {
          joinUser();
          getRecentActivities();
        }, 1000);
      }

      function testLiveUpdates() {
        log("üß™ Testing live updates...", "info");
        log(
          "Create activities in another browser tab to see live updates here!",
          "info"
        );
        getRecentActivities();
      }

      function clearLogs() {
        document.getElementById("logs").innerHTML = "";
      }

      // New Replay and Missing Activities Functions
      function replayActivities() {
        if (!socket) {
          log("Not connected to WebSocket", "error");
          return;
        }

        const from = document.getElementById("replayFrom").value;
        const to = document.getElementById("replayTo").value;
        const speed =
          parseInt(document.getElementById("replaySpeed").value) || 1000;

        if (!from || !to) {
          log("Please select both From and To dates for replay", "error");
          return;
        }

        socket.emit("replay-activities", {
          from: new Date(from).toISOString(),
          to: new Date(to).toISOString(),
          speed: speed,
        });
        log(
          `üé¨ Starting replay from ${from} to ${to} (speed: ${speed}ms)`,
          "info"
        );
      }

      function getMissedActivities() {
        if (!socket) {
          log("Not connected to WebSocket", "error");
          return;
        }

        const since = document.getElementById("missedSince").value;
        if (!since) {
          log("Please select a date to get missed activities since", "error");
          return;
        }

        socket.emit("get-missed-activities", {
          since: new Date(since).toISOString(),
        });
        log(`üì• Requesting missed activities since ${since}`, "info");
      }

      function getMissedSinceDisconnect() {
        if (!socket) {
          log("Not connected to WebSocket", "error");
          return;
        }

        // Use actual last connected time if available, otherwise use 1 hour ago
        const lastConnected =
          lastConnectedTime ||
          new Date(Date.now() - 60 * 60 * 1000).toISOString();

        socket.emit("request-missed-since-disconnect", {
          lastConnected: lastConnected,
        });
        log(
          `üì• Requesting missed activities since last disconnect (${lastConnected})`,
          "info"
        );
      }

      // Auto-connect on page load
      window.addEventListener("load", () => {
        log(
          "WebSocket test client loaded. Click Connect to start testing.",
          "info"
        );

        // Set default date/time values for replay testing
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

        document.getElementById("replayFrom").value = oneHourAgo
          .toISOString()
          .slice(0, 16);
        document.getElementById("replayTo").value = now
          .toISOString()
          .slice(0, 16);
        document.getElementById("missedSince").value = oneHourAgo
          .toISOString()
          .slice(0, 16);
      });
    </script>
  </body>
</html>
