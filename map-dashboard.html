<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Property Activity Tracker - Map Dashboard</title>

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />

    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        background: #2c3e50;
        color: white;
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        margin: 0;
        font-size: 1.5rem;
      }

      .auth-section {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .auth-section input {
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
      }

      .auth-section button {
        padding: 5px 15px;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .auth-section button:hover {
        background: #2980b9;
      }

      .status {
        font-size: 0.9rem;
        margin-left: 10px;
      }

      .status.connected {
        color: #2ecc71;
      }

      .status.disconnected {
        color: #e74c3c;
      }

      .container {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      .map-container {
        flex: 1;
        position: relative;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .sidebar {
        width: 350px;
        background: #ecf0f1;
        border-left: 1px solid #bdc3c7;
        display: flex;
        flex-direction: column;
      }

      .panel {
        margin: 10px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .panel-header {
        background: #34495e;
        color: white;
        padding: 10px 15px;
        border-radius: 8px 8px 0 0;
        font-weight: bold;
      }

      .panel-content {
        padding: 15px;
      }

      .activity-log {
        flex: 1;
        overflow-y: auto;
        max-height: 300px;
      }

      .activity-item {
        padding: 8px 0;
        border-bottom: 1px solid #ecf0f1;
        font-size: 0.9rem;
      }

      .activity-item:last-child {
        border-bottom: none;
      }

      .activity-time {
        color: #7f8c8d;
        font-size: 0.8rem;
      }

      .activity-type {
        font-weight: bold;
        color: #2c3e50;
      }

      .leaderboard-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px solid #ecf0f1;
      }

      .leaderboard-item:last-child {
        border-bottom: none;
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #3498db;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
        max-width: 400px;
      }

      .notification.success {
        background: #2ecc71;
      }

      .notification.warning {
        background: #f39c12;
      }

      .notification.error {
        background: #e74c3c;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .controls {
        padding: 10px;
        background: white;
        border-top: 1px solid #bdc3c7;
      }

      .controls button {
        width: 100%;
        padding: 8px;
        margin: 2px 0;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .controls button:hover {
        background: #2980b9;
      }

      /* Custom map markers */
      .activity-marker {
        border-radius: 50%;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        color: white;
        font-weight: bold;
        text-align: center;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .activity-visit {
        background: #e74c3c;
      }

      .activity-call {
        background: #3498db;
      }

      .activity-inspection {
        background: #f39c12;
      }

      .activity-follow-up {
        background: #9b59b6;
      }

      .activity-note {
        background: #95a5a6;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>üó∫Ô∏è Property Activity Tracker</h1>
      <div class="auth-section">
        <input
          type="email"
          id="email"
          placeholder="Email"
          value="avgpoweruser@gmail.com"
        />
        <input
          type="password"
          id="password"
          placeholder="Password"
          value="123456"
        />
        <button onclick="login()">Login</button>
        <span id="loginStatus" class="status disconnected">Not logged in</span>
        <span id="connectionStatus" class="status disconnected"
          >Disconnected</span
        >
      </div>
    </div>

    <div class="container">
      <div class="map-container">
        <div id="map"></div>
      </div>

      <div class="sidebar">
        <div class="panel">
          <div class="panel-header">üèÜ Leaderboard</div>
          <div class="panel-content">
            <div id="leaderboard">Loading...</div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-header">üìä Live Activities</div>
          <div class="panel-content">
            <div id="activityLog" class="activity-log">
              Waiting for activities...
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-header">üîé Filter Activities</div>
          <div class="panel-content">
            <label>User:</label>
            <input
              type="text"
              id="filterUser"
              placeholder="User name or email"
            />
            <label>Activity Type:</label>
            <select id="filterType">
              <option value="">All</option>
              <option value="visit">Visit</option>
              <option value="call">Call</option>
              <option value="inspection">Inspection</option>
              <option value="follow-up">Follow-up</option>
              <option value="note">Note</option>
            </select>
            <label>From:</label>
            <input type="datetime-local" id="filterFrom" />
            <label>To:</label>
            <input type="datetime-local" id="filterTo" />
            <button onclick="applyFilters()">Apply Filters</button>
            <button onclick="clearFilters()">Clear Filters</button>
            <button onclick="showSalesRepTrail()">Show Trail</button>
            <hr />
            <div style="margin-top: 10px">
              <h4>Create Activity</h4>
              <label>Property:</label>
              <select id="createActivityProperty"></select>
              <label>Type:</label>
              <select id="createActivityType">
                <!-- Options will be populated dynamically -->
              </select>
              <label>Note:</label>
              <input
                type="text"
                id="createActivityNote"
                placeholder="Optional note"
              />
              <button onclick="createActivity()" style="margin-top: 8px">
                Create Activity
              </button>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-header">‚è© Replay Activities</div>
          <div class="panel-content">
            <button onclick="replayPeriod('today')">Today</button>
            <button onclick="replayPeriod('yesterday')">Yesterday</button>
            <button onclick="replayPeriod('week')">Last 7 Days</button>
            <button onclick="replayPeriod('2weeks')">Last 14 Days</button>
          </div>
        </div>

        <div class="controls">
          <button onclick="loadProperties()">üìç Load Properties</button>
          <button onclick="loadRecentActivities()">
            üîÑ Refresh Activities
          </button>
          <button onclick="startReplay()">‚ñ∂Ô∏è Replay Last Hour</button>
          <button onclick="clearMap()">üßπ Clear Map</button>
          <button onclick="showActivityHeatmap()">
            üî• Show Activity Heatmap
          </button>
          <button onclick="removeActivityHeatmap()">‚ùå Remove Heatmap</button>
        </div>
      </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <script>
      // Global variables
      let map;
      let socket;
      let authToken = null;
      let userId = null;
      let properties = [];
      let activityMarkers = [];
      let propertyMarkers = [];
      let salesRepTrailPolyline = null;
      let allActivities = [];
      let activityTypesList = [];
      let activityTypesConfig = {};
      let heatLayer = null;
      const possibleColors = [
        "#e74c3c",
        "#3498db",
        "#f39c12",
        "#9b59b6",
        "#95a5a6",
        "#2ecc71",
        "#34495e",
        "#1abc9c",
        "#e67e22",
        "#8e44ad",
      ];
      const possibleIcons = [
        "üè†",
        "üìû",
        "üîç",
        "üìã",
        "üìù",
        "‚≠ê",
        "üö©",
        "üí°",
        "üîî",
        "üìå",
        "üß≠",
        "üéØ",
        "üóÇÔ∏è",
        "üó∫Ô∏è",
        "üõéÔ∏è",
        "üì£",
      ];

      // Fetch activity types from backend
      async function loadActivityTypes() {
        if (!authToken) return;
        try {
          const response = await fetch("http://localhost:3000/activity-types", {
            headers: { Authorization: `Bearer ${authToken}` },
          });
          if (response.ok) {
            activityTypesList = await response.json();
            // Assign random color/icon to each type
            activityTypesConfig = {};
            activityTypesList.forEach((type) => {
              const color =
                possibleColors[
                  Math.floor(Math.random() * possibleColors.length)
                ];
              const icon =
                possibleIcons[Math.floor(Math.random() * possibleIcons.length)];
              activityTypesConfig[type.id] = {
                color,
                icon,
                name: type.name,
              };
            });
            populateActivityTypeDropdowns();
            populateFilterTypeDropdown();
          }
        } catch (error) {
          showNotification(
            `Error loading activity types: ${error.message}`,
            "error"
          );
        }
      }

      function populateActivityTypeDropdowns() {
        const sidebarTypeSelect = document.getElementById("createActivityType");
        if (sidebarTypeSelect) {
          sidebarTypeSelect.innerHTML = "";
          activityTypesList.forEach((type) => {
            const option = document.createElement("option");
            option.value = type.id;
            option.textContent = type.name;
            sidebarTypeSelect.appendChild(option);
          });
        }
      }

      function populateFilterTypeDropdown() {
        const filterTypeSelect = document.getElementById("filterType");
        if (filterTypeSelect) {
          filterTypeSelect.innerHTML = "";
          const allOption = document.createElement("option");
          allOption.value = "";
          allOption.textContent = "All";
          filterTypeSelect.appendChild(allOption);
          activityTypesList.forEach((type) => {
            const option = document.createElement("option");
            option.value = type.id;
            option.textContent = type.name;
            filterTypeSelect.appendChild(option);
          });
        }
      }

      // Initialize map
      function initMap() {
        map = L.map("map").setView([34.0522, -118.2437], 10); // Los Angeles center

        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OpenStreetMap contributors",
        }).addTo(map);

        console.log("Map initialized");
      }

      // Authentication functions
      async function login() {
        const email = document.getElementById("email").value;
        const password = document.getElementById("password").value;

        try {
          const response = await fetch("http://localhost:3000/auth/login", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ email, password }),
          });

          if (response.ok) {
            const data = await response.json();
            authToken = data.access_token;
            userId = data.user.id;
            updateLoginStatus("‚úÖ Logged in");
            showNotification(`Welcome, ${data.user.firstName}!`, "success");
            connectWebSocket();
            loadProperties();
            loadLeaderboard();
            await loadActivityTypes();
          } else {
            const error = await response.json();
            showNotification(`Login failed: ${error.message}`, "error");
            updateLoginStatus("‚ùå Login failed");
          }
        } catch (error) {
          showNotification(`Login error: ${error.message}`, "error");
          updateLoginStatus("‚ùå Login error");
        }
      }

      function updateLoginStatus(status) {
        document.getElementById("loginStatus").textContent = status;
      }

      function updateConnectionStatus(status) {
        const statusEl = document.getElementById("connectionStatus");
        statusEl.textContent = status;
        statusEl.className = `status ${
          status.includes("‚úÖ") ? "connected" : "disconnected"
        }`;
      }

      // WebSocket functions
      function connectWebSocket() {
        if (!authToken) {
          showNotification("Please login first", "error");
          return;
        }

        socket = io("http://localhost:3000", {
          auth: {
            token: authToken,
          },
        });

        socket.on("connect", () => {
          updateConnectionStatus("‚úÖ Connected");
          socket.emit("join-user", { userId });
        });

        socket.on("disconnect", () => {
          updateConnectionStatus("‚ùå Disconnected");
        });

        socket.on("connected", (data) => {
          showNotification("Connected to real-time updates", "success");
        });

        socket.on("new-activity", (activity) => {
          addActivityToMap(activity, true);
          addActivityToLog(activity, "LIVE");
        });

        socket.on("notification", (notification) => {
          showNotification(notification.message, "warning");
        });

        socket.on("recent-activities", (activities) => {
          activities.forEach((activity) => addActivityToMap(activity));
          updateActivityLog(activities);
        });

        socket.on("replay-activity", (data) => {
          addActivityToMap(data.activity, false, true);
          addActivityToLog(
            data.activity,
            `REPLAY [${data.index}/${data.total}]`
          );
        });

        socket.on("leaderboard-update", (leaderboard) => {
          updateLeaderboard(leaderboard);
        });

        socket.on("error", (error) => {
          showNotification(`Error: ${error.message}`, "error");
        });

        socket.on("missed-activities-since-disconnect", (data) => {
          showNotification(
            `You missed ${data.count} activities since your last session.`,
            "info"
          );
          updateActivityLog(data.activities);
          // Replay missed activities visually on the map
          let replayIndex = 0;
          function replayNext() {
            if (replayIndex < data.activities.length) {
              const activity = data.activities[replayIndex];
              addActivityToMap(activity, false, true);
              replayIndex++;
              setTimeout(replayNext, 300); // 300ms between each for fast-forward effect
            } else {
              showNotification("Missed activities replay finished!", "success");
            }
          }
          if (data.activities.length > 0) {
            replayNext();
          }
        });
      }

      // Map functions
      async function loadProperties() {
        if (!authToken) return;

        try {
          const response = await fetch("http://localhost:3000/properties", {
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          });

          if (response.ok) {
            properties = await response.json();
            displayProperties();
            showNotification(
              `Loaded ${properties.length} properties`,
              "success"
            );
          }
        } catch (error) {
          showNotification(
            `Error loading properties: ${error.message}`,
            "error"
          );
        }
      }

      function displayProperties() {
        // Clear existing property markers
        propertyMarkers.forEach((marker) => map.removeLayer(marker));
        propertyMarkers = [];

        properties.forEach((property) => {
          const marker = L.marker([
            property.latitude,
            property.longitude,
          ]).addTo(map);
          // Popup with create activity button
          const popupContent = `
            <div>
              <h3>${property.propertyName}</h3>
              <p>${property.address}</p>
              <small>ID: ${property.id}</small>
              <div id="create-activity-form-${property.id}" style="margin-top:10px;"></div>
              <button onclick="window.showCreateActivityForm(${property.id})">Create Activity</button>
            </div>
          `;
          marker.bindPopup(popupContent);
          propertyMarkers.push(marker);
        });
        // Show create activity form in property popup
        window.showCreateActivityForm = function (propertyId) {
          const formDiv = document.getElementById(
            `create-activity-form-${propertyId}`
          );
          if (!formDiv) return;
          let optionsHtml = "";
          activityTypesList.forEach((type) => {
            optionsHtml += `<option value="${type.id}">${type.name}</option>`;
          });
          formDiv.innerHTML = `
            <label>Type:</label>
            <select id="popupActivityType-${propertyId}">${optionsHtml}</select>
            <label>Note:</label>
            <input type="text" id="popupActivityNote-${propertyId}" placeholder="Optional note" />
            <button onclick="window.createActivityForProperty(${propertyId})" style="margin-top:8px;">Submit</button>
          `;
        };

        // Create activity for property from popup
        window.createActivityForProperty = async function (propertyId) {
          if (!authToken || !userId) {
            showNotification("Please login first.", "error");
            return;
          }
          const typeId = document.getElementById(
            `popupActivityType-${propertyId}`
          ).value;
          const note = document.getElementById(
            `popupActivityNote-${propertyId}`
          ).value;
          if (!typeId) {
            showNotification("Activity type is required.", "error");
            return;
          }
          // Send to backend
          const res = await fetch("http://localhost:3000/activities", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify({
              propertyId,
              activityTypeId: typeId,
              note,
            }),
          });
          if (res.ok) {
            const activity = await res.json();
            addActivityToMap(activity, true);
            addActivityToLog(activity, "CREATED");
            showNotification("Activity created!", "success");
          } else {
            const error = await res.json();
            showNotification(
              `Error: ${error.message || "Failed to create activity"}`,
              "error"
            );
          }
        };
      }

      function addActivityToMap(activity, isLive = false, isReplay = false) {
        if (!activity.property || !activity.activityType) return;
        const typeId = activity.activityType.id;
        const config = activityTypesConfig[typeId] || {
          color: "#95a5a6",
          icon: "‚ùì",
          name: activity.activityType.name,
        };

        // Create custom marker
        const markerHtml = `
          <div class="activity-marker" style="
            width: 30px;
            height: 30px;
            background: ${config.color};
            ${isLive ? "animation: pulse 1s infinite;" : ""}
            ${isReplay ? "opacity: 0.7;" : ""}
          ">
            ${config.icon}
          </div>
        `;

        const customIcon = L.divIcon({
          html: markerHtml,
          className: "custom-div-icon",
          iconSize: [30, 30],
          iconAnchor: [15, 15],
        });

        const marker = L.marker(
          [activity.property.latitude, activity.property.longitude],
          {
            icon: customIcon,
          }
        ).addTo(map);

        const popupContent = `
          <div>
            <h4>${config.icon} ${activity.activityType.name}</h4>
            <p><strong>Property:</strong> ${activity.property.propertyName}</p>
            <p><strong>Rep:</strong> ${
              activity.salesRep?.user?.name || "Unknown"
            }</p>
            <p><strong>Time:</strong> ${new Date(
              activity.timestamp
            ).toLocaleString()}</p>
            <p><strong>Points:</strong> ${activity.activityType.weight}</p>
            ${
              activity.note
                ? `<p><strong>Note:</strong> ${activity.note}</p>`
                : ""
            }
            ${isLive ? '<span style="color: red;">üî¥ LIVE</span>' : ""}
            ${isReplay ? '<span style="color: orange;">üé¨ REPLAY</span>' : ""}
          </div>
        `;

        marker.bindPopup(popupContent);

        // Auto-remove marker after some time to avoid clutter
        setTimeout(
          () => {
            if (map.hasLayer(marker)) {
              map.removeLayer(marker);
            }
          },
          isReplay ? 5000 : 30000
        ); // 5s for replay, 30s for live

        activityMarkers.push(marker);
      }

      function clearMap() {
        activityMarkers.forEach((marker) => map.removeLayer(marker));
        activityMarkers = [];
        showNotification("Map cleared", "success");
      }

      // Activity log functions
      function addActivityToLog(activity, prefix = "") {
        const activityLog = document.getElementById("activityLog");
        const timestamp = new Date(activity.timestamp).toLocaleTimeString();

        const activityItem = document.createElement("div");
        activityItem.className = "activity-item";
        activityItem.innerHTML = `
          <div class="activity-type">${prefix} ${
          activity.activityType?.name || "Unknown"
        }</div>
          <div>${activity.salesRep?.user?.name || "Unknown"} at ${
          activity.property?.propertyName || "Unknown Property"
        }</div>
          <div class="activity-time">${timestamp}</div>
        `;

        activityLog.insertBefore(activityItem, activityLog.firstChild);

        // Keep only last 20 items
        while (activityLog.children.length > 20) {
          activityLog.removeChild(activityLog.lastChild);
        }
      }

      function updateActivityLog(activities) {
        allActivities = activities;
        const activityLog = document.getElementById("activityLog");
        activityLog.innerHTML = "";
        activities.slice(0, 20).forEach((activity) => {
          addActivityToLog(activity);
        });
      }

      // Leaderboard functions
      async function loadLeaderboard() {
        if (!authToken) return;

        try {
          const response = await fetch(
            "http://localhost:3000/sales-reps/leaderboard?limit=5",
            {
              headers: {
                Authorization: `Bearer ${authToken}`,
              },
            }
          );

          if (response.ok) {
            const leaderboard = await response.json();
            updateLeaderboard(leaderboard);
          }
        } catch (error) {
          console.error("Error loading leaderboard:", error);
        }
      }

      function updateLeaderboard(leaderboard) {
        const leaderboardEl = document.getElementById("leaderboard");

        if (!leaderboard || leaderboard.length === 0) {
          leaderboardEl.innerHTML = "<div>No data available</div>";
          return;
        }

        leaderboardEl.innerHTML = leaderboard
          .slice(0, 10)
          .map((rep, index) => {
            const name = rep.user?.name || "Unknown";
            return `
              <div class="leaderboard-item">
                <span>${index + 1}. ${name}</span>
                <span><strong>${rep.score}</strong> pts</span>
              </div>
            `;
          })
          .join("");
      }

      // Control functions
      function loadRecentActivities() {
        if (socket && socket.connected) {
          socket.emit("get-recent-activities", { minutes: 60 });
          showNotification("Loading recent activities...", "success");
        } else {
          showNotification("Not connected to server", "error");
        }
      }

      function startReplay() {
        if (socket && socket.connected) {
          const now = new Date();
          const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

          socket.emit("replay-activities", {
            from: oneHourAgo.toISOString(),
            to: now.toISOString(),
            speed: 1000,
          });

          showNotification("Starting replay of last hour...", "success");
        } else {
          showNotification("Not connected to server", "error");
        }
      }

      function applyFilters() {
        const userFilter = document.getElementById("filterUser").value;
        const typeFilter = document.getElementById("filterType").value;
        const fromFilter = document.getElementById("filterFrom").value;
        const toFilter = document.getElementById("filterTo").value;
        // Build query string
        const params = [];
        if (userFilter) params.push(`user=${encodeURIComponent(userFilter)}`);
        if (typeFilter) params.push(`type=${encodeURIComponent(typeFilter)}`);
        if (fromFilter) params.push(`from=${encodeURIComponent(fromFilter)}`);
        if (toFilter) params.push(`to=${encodeURIComponent(toFilter)}`);
        const query = params.length ? `?${params.join("&")}` : "";
        fetch(`http://localhost:3000/activities/filter${query}`, {
          headers: authToken ? { Authorization: `Bearer ${authToken}` } : {},
        })
          .then((res) => res.json())
          .then((activities) => {
            allActivities = activities;
            const activityLog = document.getElementById("activityLog");
            activityLog.innerHTML = "";
            activities.slice(0, 20).forEach((activity) => {
              addActivityToLog(activity);
            });
            clearMap();
            activities.forEach((activity) => addActivityToMap(activity));
            showNotification(
              `Found ${activities.length} activities matching filter.`,
              "success"
            );
          })
          .catch((err) => {
            showNotification(
              `Error fetching filtered activities: ${err.message}`,
              "error"
            );
          });
      }
      function clearFilters() {
        document.getElementById("filterUser").value = "";
        if (salesRepTrailPolyline && map.hasLayer(salesRepTrailPolyline)) {
          map.removeLayer(salesRepTrailPolyline);
          salesRepTrailPolyline = null;
        }
        document.getElementById("filterType").value = "";
        document.getElementById("filterFrom").value = "";
        document.getElementById("filterTo").value = "";
        updateActivityLog(allActivities);
        clearMap();
        allActivities.forEach((activity) => addActivityToMap(activity));
        // Draw sales rep trail on the map
      }
      async function showSalesRepTrail() {
        const userFilter = document.getElementById("filterUser").value;
        if (!userFilter) {
          showNotification(
            "Please enter a user name or email to show trail.",
            "warning"
          );
          return;
        }
        // Fetch activities for this sales rep
        const params = [`user=${encodeURIComponent(userFilter)}`];
        const query = `?${params.join("&")}`;
        const res = await fetch(
          `http://localhost:3000/activities/filter${query}`,
          {
            headers: authToken ? { Authorization: `Bearer ${authToken}` } : {},
          }
        );
        const activities = await res.json();
        if (!activities.length) {
          showNotification(
            "No activities found for this sales rep.",
            "warning"
          );
          return;
        }
        // Sort activities by timestamp ascending
        activities.sort(
          (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
        );
        // Get coordinates
        const latlngs = activities.map((a) => [
          a.property.latitude,
          a.property.longitude,
        ]);
        // Remove previous trail
        if (salesRepTrailPolyline && map.hasLayer(salesRepTrailPolyline)) {
          map.removeLayer(salesRepTrailPolyline);
        }
        // Draw polyline
        salesRepTrailPolyline = L.polyline(latlngs, {
          color: "#2ecc71",
          weight: 5,
          opacity: 0.7,
        }).addTo(map);
        map.fitBounds(salesRepTrailPolyline.getBounds());
        showNotification(
          `Trail drawn for ${userFilter} (${activities.length} activities).`,
          "success"
        );
      }
      window.showSalesRepTrail = showSalesRepTrail;
      // Notification system
      function showNotification(message, type = "info") {
        const notification = document.createElement("div");
        notification.className = `notification ${type}`;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
          if (notification.parentElement) {
            notification.parentElement.removeChild(notification);
          }
        }, 4000);
      }

      // Add pulse animation for live activities
      const style = document.createElement("style");
      style.textContent = `
                @keyframes pulse {
                    0% {
                        transform: scale(1);
                        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
                    }
                    70% {
                        transform: scale(1.1);
                        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
                    }
                    100% {
                        transform: scale(1);
                        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
                    }
                }
            `;
      document.head.appendChild(style);

      // Initialize when page loads
      window.addEventListener("load", () => {
        initMap();
        showNotification(
          "Map dashboard loaded. Please login to continue.",
          "info"
        );
      });

      function getUTCMidnight(date) {
        // Returns a new Date at UTC midnight for the given date
        return new Date(
          Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
        );
      }

      function getNow() {
        // Returns the current UTC time as a Date
        const now = new Date();
        return new Date(
          Date.UTC(
            now.getFullYear(),
            now.getMonth(),
            now.getDate(),
            now.getHours(),
            now.getMinutes(),
            now.getSeconds(),
            now.getMilliseconds()
          )
        );
      }

      function replayPeriod(period) {
        if (!authToken) {
          showNotification("Please login first.", "error");
          return;
        }
        let from, to;
        const nowUTC = getNow();
        switch (period) {
          case "today":
            // From UTC midnight today to now
            from = getUTCMidnight(nowUTC);
            to = nowUTC;
            break;
          case "yesterday":
            // From UTC midnight yesterday to UTC midnight today
            const yesterdayUTC = new Date(nowUTC);
            yesterdayUTC.setUTCDate(nowUTC.getUTCDate() - 1);
            from = getUTCMidnight(yesterdayUTC);
            to = getUTCMidnight(nowUTC);
            break;
          case "week":
            // From UTC midnight 7 days ago to now
            const weekAgoUTC = new Date(nowUTC);
            weekAgoUTC.setUTCDate(nowUTC.getUTCDate() - 7);
            from = getUTCMidnight(weekAgoUTC);
            to = nowUTC;
            break;
          case "2weeks":
            // From UTC midnight 14 days ago to now
            const twoWeeksAgoUTC = new Date(nowUTC);
            twoWeeksAgoUTC.setUTCDate(nowUTC.getUTCDate() - 14);
            from = getUTCMidnight(twoWeeksAgoUTC);
            to = nowUTC;
            break;
          default:
            showNotification("Invalid period.", "error");
            return;
        }
        // Debug: log the filter range
        console.log("Replay filter:", {
          from: from.toISOString(),
          to: to.toISOString(),
        });
        // Fetch activities for the period
        const query = `?from=${from.toISOString()}&to=${to.toISOString()}`;
        fetch(`http://localhost:3000/activities/filter${query}`, {
          headers: { Authorization: `Bearer ${authToken}` },
        })
          .then((res) => res.json())
          .then((activities) => {
            if (!activities.length) {
              showNotification(
                "No activities found for this period.",
                "warning"
              );
              return;
            }
            // Sort by timestamp ascending
            activities.sort(
              (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
            );
            clearMap();
            let replayIndex = 0;
            function replayNext() {
              if (replayIndex < activities.length) {
                addActivityToMap(activities[replayIndex], false, true);
                replayIndex++;
                setTimeout(replayNext, 400); // Fast-forward speed
              } else {
                showNotification("Replay finished!", "success");
              }
            }
            replayNext();
          })
          .catch((err) => {
            showNotification(
              `Error fetching activities: ${err.message}", "error`
            );
          });
      }
      async function showActivityHeatmap() {
        if (!authToken) {
          showNotification("Please login first", "error");
          return;
        }
        // Optionally, filter by time/type
        const from = document.getElementById("filterFrom").value;
        const to = document.getElementById("filterTo").value;
        const type = document.getElementById("filterType").value;
        let query = [];
        if (from) query.push(`from=${encodeURIComponent(from)}`);
        if (to) query.push(`to=${encodeURIComponent(to)}`);
        if (type) query.push(`type=${encodeURIComponent(type)}`);
        const url = query.length
          ? `http://localhost:3000/activities-heatmap?${query.join("&")}`
          : `http://localhost:3000/activities-heatmap`;
        try {
          const res = await fetch(url, {
            headers: { Authorization: `Bearer ${authToken}` },
          });
          if (!res.ok) throw new Error("Failed to fetch heatmap data");
          const points = await res.json();
          if (!points.length) {
            showNotification("No activity data for heatmap.", "warning");
            return;
          }
          // Remove previous heatmap layer
          if (heatLayer && map.hasLayer(heatLayer)) {
            map.removeLayer(heatLayer);
          }
          // Convert to [lat, lng, weight]
          const heatData = points.map((p) => [p.lat, p.lng, p.weight || 1]);
          heatLayer = L.heatLayer(heatData, {
            radius: 25,
            blur: 18,
            maxZoom: 16,
            gradient: {
              0.2: "#00f",
              0.4: "#0ff",
              0.6: "#ff0",
              0.8: "#f00",
            },
          }).addTo(map);
          showNotification(
            `Activity heatmap loaded (${points.length} points).`,
            "success"
          );
        } catch (err) {
          showNotification(`Error loading heatmap: ${err.message}`, "error");
        }
      }
      function removeActivityHeatmap() {
        if (heatLayer && map.hasLayer(heatLayer)) {
          map.removeLayer(heatLayer);
          heatLayer = null;
          showNotification("Activity heatmap removed.", "info");
        } else {
          showNotification("No heatmap to remove.", "warning");
        }
      }
      window.showActivityHeatmap = showActivityHeatmap;
      window.removeActivityHeatmap = removeActivityHeatmap;
    </script>
  </body>
</html>
